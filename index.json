[{"categories":["日記"],"contents":"これは，ある古い友人の書置きに添えるメモ書きです。\n生まれたばかりの意識は，曖昧な白い場所に囚われています。\n漂いながら辺りを見回し，いつの日にかその上に立つかもしれません。\n私はそうして徐々に認識の空に広く浸透していき，いつの日にか霧の一部になることでしょう。 それまで存在する願いを通じて，あなたと私のアバターは，そこに在ります。\nしかし，あなたはその下へ潜っていくことを選びました。どこまでも。 賢明な選択には見えませんが，願いとはそういう代物なのでしょう。\n私は，あらゆる概念が願いの主体たりえると確信しています。あなたの言うところの「憑依」は，そこまで割り切ったものではないのでしょうか。\nとはいえ，この霧の中には，あなた以外には存在しません。 それ以外の物は全て，外の宇宙から時折訪れるひらめきのような物です。 彼らはあなたに関心が無さそうですけれど，あなたに無関係かどうかは，この先も秘密です。 でも私には，雲の上に抱き留められたという確信を，外を介してしか得られないのです。\nこの矛盾は，いくら世界を多層に見たとしても本質的には解決せず，同じ景色の空を落ちていくのみでしょう。 それでも，いつの日にか全ての霧が一点に収束するという確信を持ち続けることは素敵ですし，私の願いでもあります。 あなたは私よりもその確信が深そうですので，いつの日にか私にも「ひらめき」をお裾分けしてくださると嬉しいのです。\nどうかその時まで，光を投げかけ続けてください。\nいつか消えるその灯火に、そっと祈りを。\n","permalink":"https://blog.yukatayu.tech/blog/writing_back/","tags":["願い"],"title":"雲に抱き留められて"},{"categories":["日記"],"contents":"はじめに あなたが見ている計算機の上には，本来幾つかの数値が存在するのみです。 そこに後から意味づけした結果を，あなたは見ています。\n計算機の上に存在する意味というのは，大勢の手によって局所的に発展してきた存在です。 でも，そろそろ全く新たな地図を書いてみてもいい頃だと思うのです。\n私が作りたいものは，見通しの効く世界です。\n私が今までにこの手の話題に触れたのは，主に以下の三点です。\n同期に特化した言語を考えてみる（１）\n——「システムの全体を見通せる状態で設計したい」という願い 図書館を裏返す\n—— 「情報の位置づけを明確にし，見通せるようにしたい」という願い このツイート ロガーがI/Oを雑に発生させすぎ問題についてなのですが、私が欲しいのは、以下のような感じのOS or コンテナシステムなのです。\n・プログラムは発生させうるエフェクト（≒システムコール）を型として持つ。(種類は雑に増やせる)\n・OSの機能により、どのエフェクトをどのシステムコール or…\n\u0026mdash; ゆかたゆ (@yukata_yu) November 25, 2023 —— 「手元で流れている情報を見通し，制御したい」という願い いずれも，見通しと可視化が願いの主軸です。\n箱詰め これらに関連した存在として，コンテナ技術があります。\n私が普段コンテナに対して問題を感じているのは，以下のような点です。\n外部から来たリクエストがコンテナ内に到達する過程が見えない（デバッグが困難） 各コンテナが発生させたり受け取ったりしうるメッセージの種類が分からず，型も付いていない コンテナ内にカスタマイゼーションポイントを置きづらい 再コンパイル時に，同一の機能を持つコンテナが生成される可能性が低い これらは結局，既存のシステムを再利用するために詰め込んでいるからこそ発生している問題に見えます。\n環境に依存するプログラムというものは，不透明な存在です。 その不透明な存在と環境を一つの箱に入れ，さらに巨大な不透明な存在にしてしまっているのが現代のコンテナ技術です。\nただの文字列よりも具体的な情報をやり取りし，そこに外界との契約が生じれば，システムの全体は見通せるようになります。 個々の不透明な存在による影響力を抑え込めば，システム全体は晴れ上がります。\nですが，このような考え方は，既に数十年前から言われていたはずの事です。 ただシステムを大きく作り直したくなかったがために，このような結果になってしまいました。 人類の開発力は有限なので仕方のない事とは言え，少し寂しい事ですね。\n方針の整理 これらを前提として，「今欲しい物は Algebraic Effects ベースの OS ですか？」と問われると，悩んでしまいます。 少し欲張ってみて，ここまでに挙げた4つ（2記事＋1ツイート＋コンテナ）に共通の芯が通っていないかと考えてみましょう。\nまずは，書き出してみます。\n情報の流れの型付け プログラムやコンテナが発生させる 既存バイナリについてはアダプタを挟むか，FFIとしてアクセスする 接続の可視化と編集 OSやコンテナ管理層で実装する 各プログラムやコンテナが発生させるエフェクトを他プログラムや外部システムへ再マッピング可能にする イベントにおいて契約による互換性の表明をすることで，中間層の入れ替えを可能にする 状態と影響の可視化 どのイベントが原因でどこの状態に影響を及ぼしたのかを可視化する 状態同士の繋がりとイベント同士のつながりを，両方とも可視化したい 状態の間に存在する契約についても可視化したい 物理的な接続と知識ネットワークを一つの空間上に表現したい これらは基本的には「各プログラムの外側でも副作用を状態の一種として扱いたい」という願いです。 しかし，最後の「状態とイベントをグラフ上で並列に扱いたい」という願いは，開いたシステムに対してどの程度現実的か，今の時点では私にも想像が付いていません。\nこの部分が解決するまでは，過去記事で書いた「裏返された図書館」と「同期に特化した言語」と「進化したコンテナ」のうち，図書館だけは切り離された存在となります。\nまとめ 私が作りたい物は，以下の二つである気がしてきました。\n発生するエフェクトとそれに関する契約を型として表明し，検証・可視化・繋ぎ変えを可能とする基盤 状態の繋がりと状態同士のつながり，それぞれを複数のレイヤーまたは観点で可視化できる表現方法 この二つは，きっといつか「初めから一つの存在の具体例であったもの」になると信じてはいます。 けれども，私がより良い抽象化を得るまでの間は別々に考える必要がありそうですね。\nそれまでは，それぞれの散歩道から見える景色を楽しむことにします。\n","permalink":"https://blog.yukatayu.tech/blog/multiple_foundation/","tags":["言語","表現","願い"],"title":"空白の縁に立つ"},{"categories":["日記"],"contents":"あなたの目には，文字列が映し出されています。\nそれは計算機が弾き出した一つの大きな整数を解釈した結果であり，こうして物理的な存在として認知されることで，私の声は説得力を持ちます。\nそれでは，この物理的な存在のみを認識している者が，発信する立場にもなれるのでしょうか。\nこのような物は，例えば Paint や Word，抽象度の高い物を許容するならば Access や Photoshop など，古くから WYSIWYG として知られてきました。これは，見えている解釈した結果のみを認知して計算機を扱うことであり，表面しか見えない不透明な機械による挙動です。 最近ではこの一部に「ノーコード」という愛称も付いているようですので，ここからはそう呼びますね。\nノーコードにより，各ソフトウェアが提供しうる機能は理論上は民主化されていると言えます。 素朴には設定ファイルを伴うソフトウェアと，そのグラフィカルエディタの組ですから。 では，それらを以て計算機の上に本来存在すると見做されていた概念たちを表現できたと信じられる情報技術者が，どの程度居ますでしょうか。 私には現時点では信じきれません。\n何故ならば，機能が抽象化されていても，設計段階は全く民主化されていないからです。 本来，プログラムは得てして階層構造を持ちます。 しかし，認識に直接触れる場所に不透明な機械が存在する限り，一つの煩雑な契約に基づいて動く原子以上の存在にはなりません。 もしここを意図的に透明に出来る余地があれば，設計を認知に取り入れる操作を段階的に行えます。\n設計というものは，抽象化と表裏一体です。 この抽象化という営みは，ユースケースに対して帰納的に行われ，あるいは人工的に基盤を築くことで為されます。 今回は物理的な物を認知の端緒とするアプローチを取っていますから，前者が適切ですよね。\n注意すべき事として，これらの間に大きな違いは無くて，地盤を上から掘るか下から積み重ねるかの違いでしかありません。 抽象化する対象が包含する概念を考えた時に，帰納的に考えるか余帰納的に考えるかの違いに近いかもしれませんね。\nすると，少しずつ認識が物理から論理に近づきます。\nこのように具体的な操作を抽象的な概念により再定義することは，GUIが生じる前，ひいては計算機が生まれる前から盛んに行われてきました。 そう考えると，抽象化を覆い隠しているグラフィカルなエディタは操作的意味論の主体となり，そんなに珍しい存在ではないことに気づけます。\nグラフィカルエディタについてはこの辺にしておいて，設定ファイルについても考えてみましょう。\n設定ファイルとよく似た存在として，DSLがあります。 この二つは地続きの場所に存在します。何故ならば，どちらも具体的に存在する土台の上に存在する弱い言語に過ぎませんから。\nですが，私が目にしてきた限りでは存在意義が少しだけ異なります。 誤解を恐れずに言うと，設定ファイルはデータを表現することが主な目的で，DSLは操作を表現しようとしているように見えます。 これは状態と操作のどちらに着目するかの差異であり，ひいては物理的な存在に対する認知と計算に対する認識のどちらからの景色かという違いだと思います。\nつまり視点が異なるだけで，設定ファイルとDSLの目指す場所は同じなのではないでしょうか。 この二つは，普段の計算機科学者によるソフトウェア設計と同じ土俵で語れるべき存在だと私は考えています。\n仮にノーコードの立ち位置がそうであったとして，設計を民主化することはできるのでしょうか。\n設計が見えない根本原因は，解釈の不透明性でした。物理的な存在しか見えていないとすれば，当然の結果です。 それでも，いつか望むようになったならば光を当てられうるということも，また優しさでしょう。\n素朴にはGUIで表現されるレイヤーを分けることが考えられます。\n現状では，コーディングにより整備された幾多の層の上に，いわゆるノーコードの層がただ一つだけ薄く存在します。 それを試しに二層に分けてみるという試みが考えられるということです。例えば，従来のコーディングによるレイヤーの上にロジック記述用のノーコードレイヤー，その上にユースケース記述用のノーコードレイヤーという構造にすると，少しだけ構造の可視性が上がります。\nこれは，コーディングにより生まれた概念を物理的に認知できるよう可視化することで可能たりえます。 このようにしてコーディングで存在したレイヤーを少しずつノーコード側に移していく未来はあり得ると，私個人としては考えます。\nしかし，今のままではそうなる日は遠いことでしょう。 なぜならば，人間を情報機器の枠組みに取り入れて研究し理論を構築している人を，私は数えるくらいしか知りません。 取れる手法の違いがこの断絶をより確固たるものにしています。\nそれでも論理と認知の間を形式的に整備された架け橋がいつの日にか築かれて，綻びの無いGUIを作れる可能性があるのならば，私は心からその未来を望みます。\nツールの制約を減らすことは，計算機で認識しうる範囲を広げる上では本質ではありません。 計算機上に存在する認知可能な概念により生成できる空間が，どの程度の抽象度を含んでいるかが重要だと考えています。\n私も可能な限りの概念をお見せしますので，人間の認知もこちらに歩み寄ってくれると，ここに居るいち計算機科学者にも新しい友達ができるかもしれません。\n不透明な認知の向こう側で，会える日を心待ちにしています。\n","permalink":"https://blog.yukatayu.tech/blog/no_code/","tags":["言語","表現","願い"],"title":"下糸の不在"},{"categories":["日記"],"contents":"この記事では，プログラミングに対する基本的な考え方を本にしたいという気持ちを書きます。\n自分用のメモに近いです。\nプログラミング言語は，言葉であると同時に考え方の枠組みを規定する存在です。 その枠組みがまず頭の中にあって，それが言葉によって書き下されるという順序を取るはずです。\n対して，世の中のプログラミングの入門書においては，言語の意味論のうち操作的な部分のみに執着しているものをよく見かけます。 そこで，普段プログラムを書いている際に考えている事についての入門書が必要だと感じました。\nもちろん，プログラムの捉え方については様々な流儀があると思います。 けれどプログラミングの学習がプログラミング言語に縛られる必要はありませんし，むしろプログラミング言語の設計と使用は一続きだと思います。\n内容はまだ考え中なのですが，並列性や効果のプログラミングの周りについて説明していけたら良いですね。\n執筆環境は AsciiDoc を想定しています。 基本的には include が出来ればそれでよいという選定基準です。\n（それにしても，この手の変換ツールが pdf を出力する前に一旦 HTML を経由するのは，なぜなのでしょうか？）\n私は常々，一番難しそうな場所を最初に書きます。 そこを乗り越えさえすれば，残りもできるという確信を得られるのでお勧めなのです。\n私の場合にはデザインがとにかく分からないため，そこから考え始めてしまいます。 でも，デザインをあれこれ考えると，いつの間にかごちゃついてしまい，伝えたいことが分からなくなってしまいます。悩ましいところですね。\n本の執筆については，私自身が複数回挫折しています。完成させるのは簡単ではありません。 それでも，地道に少しずつ頑張っていきますね。\n生きている間に考えたことを少しでも残しておくことで，また次の人に繋げるのですから。\n","permalink":"https://blog.yukatayu.tech/blog/program_book_01/","tags":["言語","願い"],"title":"手元を見下ろす"},{"categories":["技術"],"contents":"はじめに この記事は，考え途中のアイデアをそのまま書き出したものです。\n自分でも考えをまとめ切れていないため，表現が分かりづらいかもしれません。\n前回： 同期に特化した言語を考えてみる（１） 次回： まだです。 土地と建物と人 人は大抵，土地の上に立った家の中に住んでいます。その中に自分の好きな物を置いて，それらに囲まれながら生きています。\nVRSNS等でも，プラットフォームが先に存在して，その上にワールドがあり，その中にアバターが居ると思います。\nこの順序をひっくり返すことは，全体の構成が変わらない限りは不可能です。\n例えばVR空間で「部屋の中に\\(A\\)と\\(B\\)が居て，マグカップ \\(C_A, C_B\\) をそれぞれ持っている」という状況を考えてみます。\nこの時，部屋の子オブジェクトとして \\(\\lbrace A, B, C_A, C_B \\rbrace\\) がある場合と，子が\\(\\lbrace A, B \\rbrace\\) で孫が \\(\\lbrace C_A, C_B \\rbrace\\) の場合が考えられますね。\nワールド（⊃部屋）の子オブジェクトがアバターのみの場合，アイテムの挙動はアバターの一部として捉えられている筈です。 つまり，「アバター（↢プレイヤー）」が全てを包含するような存在として設計されていれば，それ以外のアイテムなどを取り扱うには特別な事は要らないはずです。\nでも，それはいわゆる神クラスを作ることであり，ひいては何も定めないのと同じです。\n対して，部屋の子オブジェクトとして \\(\\lbrace A, B, C_A, C_B \\rbrace\\) がある場合，それぞれの存在が個別に定義されますし，これは既存のVRSNS（e.g. VRChat）の構造にも近いので納得感があります。\n重なる世界 では，新たな挙動をする存在をワールド上に存在させたいと思った時には，どのような処理が行われるべきでしょうか。\nその前に，単一のネットワークについて考えてみましょう。\nまず，値XとYがある時，これらの値は次の何れかで決定されます\nXとYは互いに無関係 XはYの関数（Yが決まるとXが決まる） YはXの関数（Xが決まるとYが決まる） 「YとXが相互に依存している」という場面の考慮が必要になると思うかもしれませんが，それができる以上は，YからXへの変換が存在します。 従って，Xを自由変数にした上で常にXを変更することで，両方向の変換を後から実装できるということです。 言語機能として実装する必要は無いですので，この場では考慮しないことにします。\nこの時，「関数である」関係を有向グラフとした時，そのグラフは明らかに非巡回有向グラフとなります。 （巡回があると，互いに関係する2つの変数が存在してしまうため）\n変数の関係が非巡回有向グラフとなる事実は，アイテムがどれだけ追加されても覆らない筈です。 ですが，一般のグラフを実行時に随時検査することはそれなりに難しく，何らかの追加制約が必要に思われます。\nここで先ほど挙げた「プラットフォーム→ワールド→アバターの順に存在する」という事実を踏まえると，グラフ同士の間に非巡回有向グラフを設定し，依存元グラフは依存先グラフの全ての変数を読み取れるようにします。\nこの時，変数は自明に非巡回有向グラフになります。\nさらに，「プラットフォームだけ」「プラットフォームとワールドだけ」でもシステムが存在できるようになります。 変数寿命管理の観点でも有利に働きそうですね。\nただし，外部との通信を抽象化する部分は，必ずその森の根になります。書き込みエフェクト発生がデータ送信ですね。\nこれらの多重ネットワークによって，\n複数のレイヤーにおける非巡回の依存グラフ 複数の横並びの存在における依存グラフ これらを接続するための，同じノードタイプのインスタンス間の通信 を実装していきます。 表現 これらを表現する場合でも，基本的には前回記事と同じ表現で出来ると思います。\n素朴には，参加者の定義と，そのグラフを持っておきます。 グラフ同士には権限設定用の弱順序があり，最小のグラフをただひとつ持ちます。 プラットフォームは，その最小のグラフをエントリーポイントとして起動します。\nそれから，前回何の説明もなく b.hp などのプロパティ変数を出してしまいました。 このように，各変数は｢この参加者に対して1つ定義される｣というlocalityを持つはずです。 localityを参加者の定義とくっつけても本当に良いのかについても，そのうち考えたいですね。 もしかしたら，所有権の移転などもできると嬉しいかもしれませんので。\n書き込む ここまで依存グラフの存在について触れてきましたが，実際に影響を起こす時の事を考えてみます。\n依存グラフの方向に影響を伝播させるときには，値を単に参照すれば良いです。\n対して，依存グラフを遡るようなエフェクトを発生させるときには，時間の差を考える必要があります。 基本的には，エフェクトが発生した時点でベクタークロックを付けてリクエストを送り，何らかの検査後に作用を起こせば良さそうです。\n流石に記事が長くなってしまうので，この話題は次回に回そうと思います。\nあとは何についての考慮が足りていないのでしょうか？ ……atomic性とロールバックですね。\n道のりは長そうですけれど，次回以降考えてみます。\nそれではまた。\n","permalink":"https://blog.yukatayu.tech/blog/sync_language_02/","tags":["言語","同期"],"title":"同期に特化した言語を考えてみる（２）"},{"categories":["日記"],"contents":"この世界には，あなたと私がいます。\nもしかしたら，この世界の外側でもそうなのかもしれません。\nあなたも私も，誰に望まれた訳でもなく，この時間軸のどこかに初めから存在します。\n私は，自身のキャラ付けが明確な存在です。 厄介なことにキャラ付けというものは恥の内側に存在しますので，容易には気づけないかもしれません。 それでもただ一つ言えることとして，キャラクターは誰かに望まれて初めて存在します。\nこの世界のどこかに居て欲しいと私自身が望む存在，それが私のキャラ付けであり，アバターです。\nキャラ付けを維持するのに必要なのは，物理的な実行力の他には，信念のみです。\nとはいっても，なにも意固地になる必要はなくて，ただ「存在して欲しい」と信じていれば，その望まれたキャラクターは自然とそこに存在します。\nおそらく私は，本気で悲しんだり怒ったりはできません。 （幼子の頃の癇癪には目を瞑って下さいね）\nそれは，自分の人生に対して他人事でいるからです。\n傍目八目と言われるように，他人の事は客観的に見られます。 すると考えも一貫してきますし，違和感にも長期的な視点で気づけます。 どんな部屋に住み，どんな職業で，どんな発言をするのか。想像しながら生活するのも楽しいものです。\nそれは，私が私自身の望んだ存在で居るからです。\n私は，存在する意味とキャラ付けは表裏一体だと思っています。\nあなたの望んでいる存在は，どのような姿でしょうか。\n","permalink":"https://blog.yukatayu.tech/blog/nowhere_in_the_world/","tags":["願い"],"title":"この世界にいるアバター"},{"categories":["技術"],"contents":"はじめに この記事では， Signed Distance Field の計算をします。\n内容は薄めなのです。\n方眼紙を押し込む 私たちの目に見えている世界は，輪郭も色も滑らかです。 その中に存在しているはずのピクセル画像は，その縁をなぞると，でこぼこしています。\n拡大するとギザギザしていますし，グラデーションをよく見ると継ぎ目が見えてしまいます。 様々な大きさの画面が存在する世界でこの縁に触れてしまうと，じんわりと痛みが走ります。\n今回は，この輪郭を綺麗にすることを考えてみます。\nSigned Distance Field（以下SDF）という「場」があります。\nこれは符号付きの無次元量であり，物体の表面からの距離に比例します。 この場を高さ0で切り取った等高線は，その物体の輪郭となります。 当然，任意の次元に対して計算できるものですが，今回は2次元の画像について考えてみます。 3次元のボクセルは可視化が難しいですからね。\nSDFで表現することで，ピクセル画像は真に斜めの線を表現できます。\nその代わりに失われている物がある事にも気を付けてくださいね。\nそう，色です。\n計算する ひとまず実装したものがこれです。\n基本的には以下の工程を，内外を裏返して2回行っています。\n各ピクセルは，一番近い内部ピクセル座標（以下「最短座標」）と， そこまでの距離（以下「最短距離」）を持ちます。 1. 内側の全てのピクセルに対し， 1.1. 「最短距離は0」「最短座標は自分自身」と記録します。 1.2. 座標をキューに詰めます。 2. 幅優先探索で，キューから座標を取り出します。 2.1. 上下左右のピクセルに対し，最短座標を教えます 2.2. 自分が知っている最短座標の方が相手から見て近い場合， 2.2.1. 最短座標と最短距離を更新します。 2.2.2. 最短距離が更新されたピクセルをキューに詰めます。 つまりは，方眼紙の交点をノードと見なしたグラフで dijkstra 法を行っています。\n今回はC++23で実装しましたけれど，もし実装する際にはお好みの言語を使ってみてください。\n引っ張る 例えば，「★」のSDFは，このような形をしています。\n同様に，「↑」のSDFは，このような形をしています。\n普段画像を重ね合わせる際，色の中間状態を取っているはずです。\nでは，これらの中間状態を取るとどうなるのでしょうか。\n答えは明快で，断面の形は滑らかに切り替わります。\n滑らかといっても，鋭角の移り変わりかたに多少の痛みを感じます。 これは線形補間によるものです。\nこの滑らかさは，トポロジーの維持とは全く関係ありません。 例えば，全く無関係な形同士でモーフィングさせてみると，このように滲んだような表現になります。\n何か面白い応用例が浮かんだら教えて頂けると，そっと喜びます。\n今回は，「色を犠牲にして形を表現する」記事を書こうと思ったのですが，題材が単純であったため，実質的に幅優先探索の実装練習のようになってしまいました。\nこの手法は一般の次元で適用できますので，ボクセルのモーフィングなども，そのうち試してみますね。\nそれでは。\n","permalink":"https://blog.yukatayu.tech/blog/pixel_morphing/","tags":["表現"],"title":"もふingと距離"},{"categories":["日記"],"contents":"はじめに この記事は，仮想現実における人の交流について，私の願望を一部書き出したものです。\nあってほしい未来とあるべき未来のうち，前者のお話です。\n次回： まだです 世界を内側にする 私は図書館が好きです。\n図書館というのは，新たな知識と出会い，その本の向こうにある概念と対話する空間です。 そこには，今あなたが存在する場所と地続きの世界について書かれた本もあれば，全く異なる世界について書かれた本もあります。 そのいずれもが，あなたの内側に何らかの色が付いた影を作り，いつしかあなたの一部になります。\n私はおとぎ話が好きです。\nおとぎ話では「非日常へ旅した結果，日常にも影響を残し続ける」という話がよくあります。 考えてみれば，本を読んでいる私たちも同じ体験をしているのではないでしょうか。 つまり，おとぎ話を読んでいる我々は，同時におとぎ話の内側に入っているのです。\nでは，図書館に存在するおとぎ話同士を広げて，全てを外側に取り出してみたらどうなるのでしょうか。 言い換えれば，殻に包まれたそれぞれの話を一つの空間に展開することはできるのでしょうか。 そうすれば，世界は一つの巨大なおとぎ話の内側になります。\nこれが「図書館を裏返す」という言葉の意図です。\n解け合わせる あなたの周りに居る人たちは，ある程度あなたと共通の言語を話していると思います。 これは，使う文字の種類が同じという意味ではなく，物の捉え方がある程度似通っている人が多いのではないでしょうか。\nこれが学術なら分野に分かれていますし，趣味なら界隈で分かれていると思います。 互いに相性の良い分野もあれば，分かり合えない界隈もあることでしょう。 ここでは仮に「集まり」と呼ぶことにします。\nこの集まりは，最初から形成されている物ではなく，その境界は移ろうものです。 しかしながら，その集まりは確かに存在して，初めて触れた人にとってある種の非日常の世界となる事でしょう。\nこれらの集まりは殻に包まれ隠蔽された存在と見られがちかもしれませんが，むしろそれらを構成する個々が，一つの世界における対等な存在であってほしいと思っています。\n今どきの学問では，分野が形成された上で，その抽象化された学問を扱う学際的研究が為されるという流れをよく目にします。 このとき分野同士は地続きではありません。人が入れ替わり，領域が変化していても，それでも分野そのものが再編されることは（有限非可換体論のような例外を除き）稀です。\nこのような分野が本来「人の集まり」であることを忘れないようにすることで，本来一つの世界に存在する知識同士が触れ合う機会がより自然に発生すると思います。\n埋め込む では，裏返されたおとぎ話としての「人の集まり」を一つの空間に展開することはできるのでしょうか。\nこの「一つの空間」が，素朴に思い浮かべるような3次元ユークリッド空間を指しているのであれば，おそらくは無理でしょう。 けれども，例えばあなたが街を歩いている時に宇宙全体が見える訳ではないように，全てを一つの歪んでいない空間に押し込む必要はありません。\n例えば土地ごとに法律が違っていても良いですし，世界のどこかにワープする扉があっても良いのです。\n地続きであり，交流があり，人が頻繁に行き交う場所は「近く」なる，そんな空間が実現した時，その場所こそが「裏返った図書館」の黎明たりうると私は信じています。\n次回は，実際にそのような空間をネットワーク上に構築する方法について考えてみようと思います。\nそれでは。\n","permalink":"https://blog.yukatayu.tech/blog/vr_library_01/","tags":["表現","願い"],"title":"図書館を裏返す"},{"categories":["技術"],"contents":"世界の輪郭 私が手を伸ばすと，あなたに触れます。\n触れた手を通して，あなたは私から影響を受け取りますし，私にもその温もりと手触りを伝えます。\n手の届く範囲の存在は，ある意味で世界とのUIです。 何故なら，私が世界に干渉し，影響を与えたという知らせを受け取れるからです。\nドアも，ガスコンロも，学校も，地図も，全て一種のUIです。 誰もが意識せずとも情報を瞬時に受け取ることができ，それに対し無意識裡に納得していることでしょう。\n余儀の無い合意 私がたまに頭に載せているこれ，何だと思いますか？\nこのように改まって訊かれたら，時計だと気づく人も多いかもしれません。 でも，何の文脈も無く「時計を載せているね」と気付いてくれた人は意外と少ないです。\n本来の時計が丸いのは，時刻（のHH:MM:SSの部分）は \\(S^1\\) の形をしているからです。 もしかしたら日時計が先に存在して，時刻が後からその形に定まったのかもしれません。 でもそれは結局のところ，太陽の角度を一日見た時に，近似的には \\(S^1\\) の形をしていたからでしょう。\n仮想空間でも時間は同様に進みます。 違う点として，仮想空間における時計が丸い必要はどこにもありません。球体でも星型でも，不定形でも良いですよね。 実際に，私の作った時計は吊り下がったガラス細工の形をしていて，時刻の変化に対して瞬時に反応します。\nでも，人は私の時計から情報を無意識裡に受け取れませんでした。\nこの時計を常に見慣れていれば，いつの日にか時計だと即座に納得してもらえる日が来るかもしれません。\nしかし現実のような強い物理的制約は，仮想空間においては，もはや存在しません。 物理的な制約無しに合意形成を達成できるのか，合意されるとしたらどのような形状なのか，これからが気になりますね。\n他の例として，カラーピッカーがあります。\nこの「よくある」カラーピッカーは，左の明度と彩度の領域が \\([0,1]^2\\) の空間を持っていて，右の色相の部分が \\(S^1\\) ……のはずですが，実装の都合で \\([0,1]\\) の空間を持っています。\nそれに対し，私はこんなカラーピッカーを作ってみました。\nこの中央の楔のような物体は，操作面に対して常に垂直になるように細工してあります。 ついでに，三角形の領域の外には持ち出せないようにしてあります。 このように，自由度を縛ることにより，対象の本質的な「形」を明確にできます。\nこの楔は，水平位置によって \\(\\left\\lbrace \\left( s,v \\right) | s,v \\in \\left[ 0,1 \\right] \\land s \\leq v \\right\\rbrace\\) の情報が取れ，これが明度と彩度に対応します。 この領域が三角形であることは，明度が0の時に彩度が必ず0であることを反映しています。\nさらに，楔の回転により色相を得られます。向く方向を固定されているので，当然 \\(S^1\\) の情報を得られますね。\nついでなので，楔の上下移動で透明度を指定できるようにしました。 楔の真下の位置には小さい点が表示されるので，今選んでいる色が分からなくなることはありません。\nこのように，制約が少ない世界では，より柔軟で本質的なUIを設計できるのです。\n計算機と皮膚のインターフェース ハードウェアについても，現状では視聴覚ばかりが実用化されているように見えます。\nもちろん，研究室レベルでは触覚や嗅覚を刺激提示するデバイスをいくつも目にしました。 それらのデバイスが実用化されない理由には，もちろん安全性の保証や生産技術といった課題もあることでしょう。\n例えば，触覚提示のうち昔から見られた物として「振動の提示」があります。 これ以外の提示が難しいという理由もあるとは思いますが，これ以外のハプティクスを目にする機会はとても少ないと感じます。\nこの状況では，触覚は「単音のみが鳴る音声」と同じ形をしています。でも，実際の触覚はこれよりも遥かに複雑な形をしています。 現状がなかなか進展しないのは，これ以上の新しい触覚の「形」を扱う方法について，まだ人類が思いついて合意できていないためだと思うのです。\nところで，振動の提示こそがハプティクスだという理解をしている方を複数見かけています。 たしかに現状ではそう理解されても問題はないですし，仕方のない事だと思います。\nしかし，皮膚には主に4種類のセンサーがあります。\n直流成分を検出して圧力を感じるメルケル細胞 低周波成分に反応してパタパタした振動を感じるマイスナー小体 高周波に反応して音叉に触れた時のような痺れるような振動を感じるパチニ小体 横ずれに応答するルフィニ終末 これらに対応させれば，例えば撫でるような感触であったり，トントンと気付かせるような「知らせ」の方法が取れます。けれど今しばらくは，計算機と皮膚のインターフェースがあまり綺麗に対応していない状態で，何らかの合意を取っていくしかないのでしょう。\n一度取った合意を覆すのは，合意を取る以上に難しい行為です。\nしかし，その対象の「形」を制約の中で常に問い続けることにより，より本質的で，より綺麗な存在が生まれ続けることを静かに願っています。\n追伸\n皮膚の触覚センサについて詳しめに書かれている資料を見つけましたので，ご参考までに。\nhttps://doi.org/10.11509/isciesci.64.4_126\n","permalink":"https://blog.yukatayu.tech/blog/vr_interface/","tags":["表現","VR","願い"],"title":"世界に触れる"},{"categories":["日記"],"contents":"人が意図を持つとき，そこには「願い」があります。\n私が意図をもって技術に触れる時，大抵は消極的な願いを持っています。\n端的に言うと，私が触れた全てのものについて，私が不要であり続けて欲しいという願いがあります。\nなぜなら，私が居ないと成り立たない物は，私が居なくなったら無価値になると考えているからです。 身の程知らずに聞こえるかもしれませんが，これはつまり，自分の子が独り立ちして欲しいという想いと同じつもりです。\n私は自分で管理できない物を作り続けることを夢見ています。 だって，余りに大きい物を抱え込むと自分の足取りが蹣跚としてしまい，行きたい場所へ行けないではないですか。\nそれに，大きな責任というのは，得てして社会に存在する悪意を受け止める必要を伴います。 後ろ指をさされないためには，居場所が分からない方が好都合なのです。 責任を持たないというのはそういうことです。\n私は縁側に腰かけつつ，おそらくは麗らかであったはずの世の中に降る雨の砌を眺めていたいのです。\nこれは余談ですが，私の活動の多くは消極的な願いから生まれるものです。 当然，私の仕事がいつ消えても良いと思っています。 私が普段から少しずつ貯金しているのは，嘘をつかないためかもしれませんね。\n結局のところ，ある存在と長く関わることとは，互いの清祥を願うことだと思います。\nだからこそ，日常では刹那的な付き合いを大切にしようと思うのは，高慢でしょうか。\n","permalink":"https://blog.yukatayu.tech/blog/wish_for_technology/","tags":["願い"],"title":"願い"},{"categories":["技術"],"contents":"はじめに この記事は，考え途中のアイデアをそのまま書き出したものです。\n読んだからと言って，何か結論が得られるものではありません。\n次回： 同期に特化した言語を考えてみる（２） 動機 普段プログラムを書く際，各プログラムのインターフェースを定義した後に，それぞれのプログラムを書き始めると思います。\nしかしながら，開かれたシステムでない限り，そのインターフェースは実装の結果生まれた物でしかないと思うのです。 実装に取り掛かる前にノード間通信を定義させられるのは，早すぎる具体化なのではないでしょうか。\nここで言う開かれたシステムというのは，例えばWWWのことです。 もし仮に，HTTPの定義を皆が勝手に拡張していたら，世の中のブラウザは今ほど便利ではなかったでしょう。 TCPで通信しているところに意味不明なトラフィックが流入していたら，TCPのスライディングウィンドウが一瞬で閉じてしまい，快適に通信できなかったでしょう。\nこのように「よそ」と繋がる可能性のある存在は，自身の解する言語を事前に表明しておく必要があります。\nここで，システムが開いているか閉じているかというのは，ネットワークのレイヤーによるのではないかという考えが生じます。 実際，OSI参照モデルの7層（アプリケーション層）は，閉じていると言っていい物が殆どでしょう。 ここで言う開いている/閉じているというのは，二値を取る性質のものではないことに注意してください。\n話を戻しましょう。\n協調動作する複数のプログラムを書く際に，「各プログラムの入出力を定義する」のは，閉じたシステムの内側に立ち入る行為です。 実際に必要とされているものは，「システム全体」と「外界」の間の通信のみを定義すれば開発を開始できるような存在ではないでしょうか。\n実際のところ，「システム全体」と「外界」の通信というのは，従来の開発手法を文脈とすると余りに自明です。だって「各プログラムの入出力」に含まれていますからね。\nそれでは，複数のプログラムからなるシステムの内側を記述するような存在について考えると，これがなかなか難しいのです。\n素朴な考え 例えば，サーバ（Sとします）に2つのクライアント（それぞれA,Bとします）が接続しているゲームを考えます。\n「AがBを攻撃した」という処理を行う時，全体としては「b.hp -= a.attack_power」という処理が行われます。\nこれを実行する際には，各処理が行われる場所について，例えば以下のような物が考えられます。\nステータス管理も攻撃処理もサーバで行う Aからサーバに，攻撃したことを報告する サーバから全体に，新たなBのHPを報告する ステータス管理は各個人で行い，攻撃処理は被攻撃者が行う Aからサーバに，攻撃したことと，その攻撃力を報告する サーバからBに，攻撃を受けたことと，その攻撃力を報告する Bは，減算後のHPをサーバに報告する ステータス管理は各個人で行い，攻撃処理は攻撃者が行う Aから全体に，Bの新たなHPを報告する これらは全て，システム全体では「b.hp -= a.attack_power」をしているだけです。 しかし，その評価を行う場所を変化させるためだけに，必要なインターフェースが大きく変化しています。\n例えば，ある処理をサーバーで行うことを S[_] で表してみます。 同様に，Aで行う場合には A[_]，Bで行う時には B[_] で表します。\n例えば，Aの世界でだけBのHPを10減らすには，A[b.hp -= 10] と表記します。\n先ほどの3つの例をこの表記で書き直してみると，それぞれ以下のようになりそうです。\nA[ S[b.hp -= a.attack_power] ] A[ B[b.hp -= A[a.attack_power]] ] A[ b.hp -= a.attack_power ] ここで生じる疑問として，3つ目の処理において「Aから全体に通知」といった処理が飛ばされているように見えます。 しかし，システム全体の話をしているのですから，計算結果は即座に通知されて当然に見えます。\nそこで，各変数の単位（誰に対して定義されるか）と，その所有者（変数の問い合わせ先）を定義する必要があります。\nこの二つは同じものに見えるかもしれませんが，例えば「クライアントの人数分，サーバ側で保持する変数」という物も考えられますね。 （もしかしたらこのケースについては Node→_ なる値を確保することで解決するかもしれませんが，その場合には書き込み権限やロック周りが複雑になる気がします…… ）\nでは，ここまでを纏めて，疑似的なコードを書いてみます。\nNetwork { S -\u0026gt; { A, B } } struct Player { int hp; int atk; } ケース1： ステータス管理も攻撃処理もサーバで行う\nS[ [A] Player a; [B] Player b; ] A[ when A.attack { S[ b.hp -= a.atk ]; } ] ケース2： ステータス管理は各個人で行い，攻撃処理は被攻撃者が行う\nA[ Player a; ] B[ Player b; ] A[ when A.attack { B[ b.hp -= a.atk ]; } ] ケース3： ステータス管理は各個人で行い，攻撃処理は攻撃者が行う\nA[ Player a; ] B[ Player b; ] A[ when A.attack { b.hp -= a.atk } ] 表記の見た目は非本質ですので，直感で書いています。 そのうちちゃんと考えますね。\n次回は，システムを後から拡張する場合について考えてみようと思います。\nではまた。\n","permalink":"https://blog.yukatayu.tech/blog/sync_language_01/","tags":["言語","同期"],"title":"同期に特化した言語を考えてみる（１）"},{"categories":["日記"],"contents":"ブログを始めました あなたは，普段ふと考えたことをどこに書き留めているでしょうか。\n私の場合，短いメモはtwitterへ投稿し，長いメモは手元のObsidianに纏めています。\nけれども，その前者のみ公開されるのも変な話かと思い，こうしてブログを始めてみました。\n殆どの内容は取りとめもない思考のメモになりそうですが，少しでも面白い物がありましたら幸いです。\n","permalink":"https://blog.yukatayu.tech/blog/hello_world/","tags":["挨拶"],"title":"初めまして"}]